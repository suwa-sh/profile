import{z as d,w as y,j as b}from"../lit-html.9W9Vuh48.js";const v={resolveDirective:d.V,ElementPart:d.F,TemplateInstance:d.R,isIterable:d.D,ChildPart:d.I};/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const p={ATTRIBUTE:1,PROPERTY:3,EVENT:5,ELEMENT:6};/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const w=e=>e===null||typeof e!="object"&&typeof e!="function",E=(e,a)=>e?._$litType$!==void 0,$=e=>e?._$litType$?.h!=null,g=e=>e.strings===void 0;/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const{TemplateInstance:A,isIterable:T,resolveDirective:f,ChildPart:h,ElementPart:P}=v,x=(e,a,i={})=>{if(a._$litPart$!==void 0)throw Error("container already contains a live render");let l,r,n;const t=[],c=document.createTreeWalker(a,NodeFilter.SHOW_COMMENT);let o;for(;(o=c.nextNode())!==null;){const s=o.data;if(s.startsWith("lit-part")){if(t.length===0&&l!==void 0)throw Error(`There must be only one root part per container. Found a part marker (${o}) when we already have a root part marker (${r})`);n=I(e,o,t,i),l===void 0&&(l=n),r??=o}else if(s.startsWith("lit-node"))R(o,t,i);else if(s.startsWith("/lit-part")){if(t.length===1&&n!==l)throw Error("internal error");n=_(o,n,t)}}if(l===void 0){const s=a instanceof ShadowRoot?"{container.host.localName}'s shadow root":a instanceof DocumentFragment?"DocumentFragment":a.localName;console.error(`There should be exactly one root part in a render container, but we didn't find any in ${s}.`)}a._$litPart$=l},I=(e,a,i,l)=>{let r,n;if(i.length===0)n=new h(a,null,void 0,l),r=e;else{const t=i[i.length-1];if(t.type==="template-instance")n=new h(a,null,t.instance,l),t.instance._$AV.push(n),r=t.result.values[t.instancePartIndex++],t.templatePartIndex++;else if(t.type==="iterable"){n=new h(a,null,t.part,l);const c=t.iterator.next();if(c.done)throw r=void 0,t.done=!0,Error("Unhandled shorter than expected iterable");r=c.value,t.part._$AH.push(n)}else n=new h(a,null,t.part,l)}if(r=f(n,r),r===y)i.push({part:n,type:"leaf"});else if(w(r))i.push({part:n,type:"leaf"}),n._$AH=r;else if(E(r)){if($(r))throw Error("compiled templates are not supported");const t="lit-part "+C(r);if(a.data!==t)throw Error("Hydration value mismatch: Unexpected TemplateResult rendered to part");{const c=h.prototype._$AC(r),o=new A(c,n);i.push({type:"template-instance",instance:o,part:n,templatePartIndex:0,instancePartIndex:0,result:r}),n._$AH=o}}else T(r)?(i.push({part:n,type:"iterable",value:r,iterator:r[Symbol.iterator](),done:!1}),n._$AH=[]):(i.push({part:n,type:"leaf"}),n._$AH=r??"");return n},_=(e,a,i)=>{if(a===void 0)throw Error("unbalanced part marker");a._$AB=e;const l=i.pop();if(l.type==="iterable"&&!l.iterator.next().done)throw Error("unexpected longer than expected iterable");if(i.length>0)return i[i.length-1].part},R=(e,a,i)=>{const l=/lit-node (\d+)/.exec(e.data),r=parseInt(l[1]),n=e.nextElementSibling;if(n===null)throw Error("could not find node for attribute parts");n.removeAttribute("defer-hydration");const t=a[a.length-1];if(t.type!=="template-instance")throw Error("Hydration value mismatch: Primitive found where TemplateResult expected. This usually occurs due to conditional rendering that resulted in a different value or template being rendered between the server and client.");{const c=t.instance;for(;;){const o=c._$AD.parts[t.templatePartIndex];if(o===void 0||o.type!==p.ATTRIBUTE&&o.type!==p.ELEMENT||o.index!==r)break;if(o.type===p.ATTRIBUTE){const s=new o.ctor(n,o.name,o.strings,t.instance,i),u=g(s)?t.result.values[t.instancePartIndex]:t.result.values,m=!(s.type===p.EVENT||s.type===p.PROPERTY);s._$AI(u,s,t.instancePartIndex,m),t.instancePartIndex+=o.strings.length-1,c._$AV.push(s)}else{const s=new P(n,t.instance,i);f(s,t.result.values[t.instancePartIndex++]),c._$AV.push(s)}t.templatePartIndex++}}},C=e=>{const a=new Uint32Array(2).fill(5381);for(const l of e.strings)for(let r=0;r<l.length;r++)a[r%2]=33*a[r%2]^l.charCodeAt(r);const i=String.fromCharCode(...new Uint8Array(a.buffer));return btoa(i)};globalThis.litElementHydrateSupport=({LitElement:e})=>{const a=Object.getOwnPropertyDescriptor(Object.getPrototypeOf(e),"observedAttributes").get;Object.defineProperty(e,"observedAttributes",{get(){return[...a.call(this),"defer-hydration"]}});const i=e.prototype.attributeChangedCallback;e.prototype.attributeChangedCallback=function(t,c,o){t==="defer-hydration"&&o===null&&l.call(this),i.call(this,t,c,o)};const l=e.prototype.connectedCallback;e.prototype.connectedCallback=function(){this.hasAttribute("defer-hydration")||l.call(this)};const r=e.prototype.createRenderRoot;e.prototype.createRenderRoot=function(){return this.shadowRoot?(this._$AG=!0,this.shadowRoot):r.call(this)};const n=Object.getPrototypeOf(e.prototype).update;e.prototype.update=function(t){const c=this.render();if(n.call(this,t),this._$AG){this._$AG=!1;for(let o=0;o<this.attributes.length;o++){const s=this.attributes[o];if(s.name.startsWith("hydrate-internals-")){const u=s.name.slice(18);this.removeAttribute(u),this.removeAttribute(s.name)}}x(c,this.renderRoot,this.renderOptions)}else b(c,this.renderRoot,this.renderOptions)}};
